 [preface]

== Introduction
The OpenDaylight (ODL) project is an open source, hardware-agnostic platform you can use to virtualize networking services based on your application's requirements, which is commonly referred to as Software-Defined Networking (SDN). In SDN the applications communicate their operating needs via APIs to a centralized controller, which oversees everything in the network. The controller alone directs all network communication based on component availability so your applications run at higher speeds with increased performance and scalability. 

When you deploy new applications in a traditional environment, you often have to modify the entire network to ensure ample and accurate resources to accommodate changes. For example, introducing virtual machines (VMs) increases datacenter network complexity and requires a high touch approach to ensure components still play together as required after any additions or changes. Switches can see only the switches directly next to them so don't have a comprehensive understanding of the network. With this limited information, the switches control all routing but far less efficiently because they can't see all the resources available to move traffic through the network. 

=== OpenDaylight goal
As a collaborative, open source project ODL's goal is to integrate open standards and open APIs to support a multitude of networking scenarios, accelerating adoption of SDN and Network Functions Virtualization (NFV). ODL's transparent approach works for your current networking needs and adapts to accommodate changes as application requirements and scope evolve. 

=== Who should read this guide and what's in it?
The Getting Started Guide  is for those considering or already using ODL, including IT decision-makers and end-users as well as developers and contributors to the project. ODL is supported by a global community and has a release cadence of roughly every six months, with the current Beryllium release preceded by Lithium, Helium, and the first release, Hydrogen.

This document explain the basics of ODL's architecture and components and provides installation instructions. In addition, ODL has more than 50 projects under its auspices that address specific networking requirements you may have and methods to execute against them. Here you'll find expanded explanations and use cases for several projects, including ones that are important for using OpenDaylight with OpenStack. As part of an ongoing effort, ODL is working to provide more use cases and case studies in the near future. For projects not covered here, we provide links to development documentation on the ODL wiki.

//list all projects with updated documentation in this release. We are targeting OpenFlow, BCP-PCEP, AAA, Group-based policy, NIC, OpenStack Integration (Net-virt), OVSDB,VTN, Service Function Chaining.

.This document contains:
// This list subject to organizational changes and additions/revisions.
* OpenDaylight overview and architecture
- Components
- Support for REST APIs
- DXLUX web interface
- MD-SAL clustering
* Installing OpenDaylight
- Target environment
- Known issues and limitations
* Download and install
- OpenDaylight Beryllium
* OpenDaylight projects and how to use them

== OpenDaylight overview and architecture
Here we take a closer look at ODL and its architecture. If you're already familiar with it and want to get on with installation, skip to Installing OpenDaylight.

//Verify chapter title in sentence above after edits made.

=== Running environment
ODL software is designed to run on a Java Virtual Machine (JVM). The platform is based on the the Open Service Gateway Initiative (OSGi) whose JVM service registry provides a specification for ODL plugins, defining their lifecycle and how they interact with each other. Plugins use the JVM to publish, discover, and bind services in a service-oriented architecture (SOA). You can can use ODL on any operating system and hardware that has a Java Runtime Environment (JRE).

=== OpenDaylight architecture
Figure 1 displays the ODL architecture, the components of which we  address in this section.

//introduce and paste screenshot of ODL architecture from newer slide set. Jan Medved, slide 4. Is this the slide we should use here?

=== Network devices, Operating Support Systems,  Business Support Systems, and external applications 
To give a user perspective, we start with network devices, Operating Support Systems (OSS), and Business Support Systems (BSS) that sit on top of the ODL architecture. OSS assembles services and helps operators build and optimize the network. BSS allows operators to manage accounts and payments, customer support,and service modification. External applications are...

For context as we proceed with the following explanations, an example of an ODL user could be a web provider that sells goods and services dependent on a legacy network system unable to handle growth in customers, transactions, inventory, and customer service. Using ODL, that user can implement open APIs in programs within ODL to specify networking requirements without having to configure the network. _clarify with Colin_


//Jan-Simon suggested using an OpenStack use case above. I need someone with more technical knowledge to help with that. Colin? Follow up with Colin.

//1. Case study – high-level of user doing something with ODL or SDN controller, e.g., provision routes across WAN.2. User Story/Study – what features need to be in ODL controller to allow participants to get something done. Gets into what is functionality and interface for ODL to exist.3. Case studies, e.g., how ATT is using OpenDaylight. More for User Guide but could use simple example here.

.OSS functions expedite: 
* Video streaming 
* Chatting online
* Using an application, and so on

.BSS functions expedite: 
* Pre-paying an account
* Paying bills
* Buying and activating a new device
* Contacting customer service, and so on

=== Applications/services
At this level, ODL hosts your applications _give more detail here and differentiate between what's on top of ODL and the applications within it_. 

==== Microservices architecture
Applications on the ODL platform are based on a microservices architecture consisting of narrowly-focused, independently deployable services that communicate with each other using open APIs. 

Open APIs provide a set of routines, protocols, and tools for your ODL software applications, specifying how software components should interact. The APIs allow the developer to abstract networking requirements, while ensuring the program can interoperate and communicate clearly and quickly without need of manual network modifications. 

==== NETCONF protocol
The NETCONF protocol on the ODL platform alongside applications provides network management capabilities and supports complex network configuration changes involving multiple devices, with operations on top of a remote procedure call (RPC). The protocol enables changes with mechanisms that install, manipulate, and delete the configuration of network devices.

You can define additional capabilities to extend basic NETCONF functionality to support more features. The NETCONF server and client communicate the new protocol capabilities for an enhanced implementation during session setup. 

Data and messages in the protocol are configured with XML-based encoding. 

//Everything from here down is being HEAVILY edited and reorganized. Read with the proviso that I know it isn't at all done. OR don't read, and I will provide an update on Tuesday.
==== MD-SAL 
At the core of ODL is a model-drive service abstraction layer (MD-SAL). It unifies northbound  and southbound APIs and data structures for the controller's services and components. 

Yet Another Next Generation (YANG) is a modular data modeling language for the NETCONF network configuration protocol. It models both configuration data as well as state data of network elements. 

.It allows:
* Modeling the structure of XML data and functionality provided by controller components
* Defining semantic elements and their relationships
* Modeling all the components as a single system
* Self-describing data, because YANG is based on XML, which the controller's northbound APIs can consume in a raw format, along with the data’s schema

Utilizing a schema language simplifies development of controller components and applications. A developer of a module that provides some functionality (a service, data, and functions/procedure) can define a schema and thus create simpler, statically typed APIs for the provided functionality, and thereby lower the risk of incorrect interpretation of data structures exposed through the Service Abstraction Layer.

DOM – a document object model – a tree structure. A DOM is the specification for how objects in a Web page (text, images, headers, links, etc.) are represented. The DOM defines what attributes are associated with each object, and how the objects and attributes can be manipulated. Dynamic HTML (DHTML) relies on the DOM to dynamically change the appearance of Web pages after they have been downloaded to a user's browser.
The DOM in ODL is YANG. It a programming interface for HTML, XML and SVG documents (SVG - Scalable Vector Graphics – is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation.) 
YANG provides a structured representation (a tree) of the document and it defines a way programs can access the structure so that they can change the document structure, style and content. YANG provides a representation of the document as a structured group of nodes and objects that have properties and methods. Nodes can also have event handlers attached to them, and once that event is triggered the event handlers get executed. Essentially, it connects web pages to scripts or programming languages.
Though often accessed using JavaScript, the DOM itself is not a part of the JavaScript language, and it can be accessed by other languages, though this is much less common.

.REST on top of an application, which is used to build lightweight, mantainable, and scalable web services.
//Need help to clarify this.
.RESTCONF 


FigureIn the middle of the figure above, you see that the "Controller Core," which in ODL is a model-driven service abstraction layer (MD-SAL) architecture that unifies northboand and southbound APIs. Northbound APIs sit between the controller and application services, and they abstract and communicate network capabilities to define network flows for applications and implement application requests to the network relayed to it through northbound APIs. to ODL applications. NB APIs  abstracts the network capabilities/information and opens the abstract/logic network to applications. The northbound interface describes the area of protocol-supported communication between the controller and applications or higher layer control programs.In an enterprise data center, functions of northbound APIs include management solutions for automation and orchestration, and the sharing of actionable data between systems.

Southbound APIs enable communication between the ODL controller and network virtualization protocols.  

Southbound protocol
In SDN, the southbound interface is the OpenFlow protocol specification. Its main function is to enable communication between the SDN controller and the network nodes (both physical and virtual switches and routers) so that the router can discover network topology, define network flows and implement requests relayed to it via northbound APIs. 



OpenFlow is a southbound protocol. With SDN, the controller tells the switch what to do.
OpenFlow is a controller that talks to the switch to set up a table to do the following:
1.	Drop the packet
2.	Send the packet in.
The controller can limit traffic through particular switches when it sees congestion.


//delete this: from Melissa: OpenDaylight uses a model-driven approach to describe the network, the functions to be performed on it and the resulting state or status achieved. By sharing YANG data structures in a common data store and messaging infrastructure, the core of OpenDaylight allows for fine-grained services to be created then combined together to solve more complex problems. In the ODL MD-SAL, any app or function can be bundled into a service that is then then loaded into the controller. Services can be configured and chained together in any number of ways to match fluctuating needs within the network. 
●	Only install the protocols and services you need 
●	Ability to combine multiple services and protocols to solve more complex problems as needs arise
●	Modular design allows anyone in the ODL ecosystem to leverage services created by others 

// TODO: uncomment the following lines when we have them to the point we think they're useful.
// OpenDaylight makes use of the following third-party tools:
//
// * *Maven*: OpenDaylight uses Maven for easier build automation. Maven uses pom.xml
// (Project Object Model) to script the dependencies between bundles.
//
// * *OSGi*: OSGi framework is the back-end of OpenDaylight as it allows dynamically
// loading bundles and packages JAR files, and binding bundles together for exchanging
// information.
//
// * *JAVA interfaces*: Java interfaces are usually generated by compiling the YANG project. Java interfaces are used for event listening, specifications, and forming
// patterns. This is the main way in which specific bundles implement call-back functions for events and also to indicate awareness of specific state.
//
// * *REST APIs*: Most of the REST APIs in OpenDaylight are defined using YANG tools and are RESTCONF APIs.
//
// * *Karaf*: TBD

For a more detailed information about OpenDaylight, see the and _OpenDaylight User Guide_, _OpenDaylight
Developer Guide_.

