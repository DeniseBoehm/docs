 [preface]

== Introduction
The OpenDaylight (ODL) project is an open source, hardware-agnostic platform you can use to virtualize networking services based on your applications' requirements, which is commonly referred to as Software-Defined Networking (SDN). ODL's platform implements SDN, integrating open standards and open APIs to support a multitude of networking scenarios. ODL's goal is to accelerate adoption of SDN and Network Functions Virtualization (NFV) with a transparent approach for your current networking needs that adapts to accommodate changes as application requirements and scope evolve. 

One example of an end-user who wants to get started with ODL could be a web provider that sells goods and services. The company's legacy network system may not be able to handle growth in customers, transactions, inventory, and customer service needs so it wants to try SDN to accommodate expansion. 

Using ODL and its open APIs, application developers can abstract their networking needs, staying out from under the hood while ODL ensures software programs can interoperate and communicate clearly and quickly. With application services decoupled and the ODL controller directing all networking, your applications run at higher speeds with increased performance and scalability.

 
Other end-users may want to

///create some other basic use cases. Ask Colin/Casey for something simple but widely needed/used.

//1. Case study – high-level of user doing something with ODL or SDN controller, e.g., provision routes across WAN.2. User Story/Study – what features need to be in ODL controller to allow participants to get something done. Gets into what is functionality and interface for ODL to exist.3. Case studies, e.g., how ATT is using OpenDaylight. More for User Guide but could use simple example here.

//ODL there is no big picture. Ex: A customer with a legacy network wants to make it possible to manage. Or there is a customer who wants to use OpenFlow and that’s all he wants to use. Or someone wants to use OpenStack with ODL.

=== Who should read this guide and what kind of information does it provide?
This document is for end-users of OpenDaylight as  well as developers and potential contributors to the project, which is supported by a global community and has a release cadence of roughly every six months. The current Beryllium release is preceded by Helium and Lithium, the first and second releases, respectively.

In this Getting Started Guide we explain the basics of ODL's architecture and components and provide installation instructions. ODL has more than 50 projects under its auspices that address different networking requirements you may have and methods to execute against them. This document provides expanded explanations and use cases for several projects, including ones that are important for using OpenDaylight with OpenStack. As part of an ongoing effort, ODL is working to provide more use cases and case studies in the near future. For projects not covered here, we provide links to development documentation on the ODL wiki.

This document contains:

.  OpenDaylight overview and architecture
. Installing OpenDaylight
.. Target environment
.. Known issues and limitations
.. Download and install
... OpenDaylight Beryllium
... Components
... Support for REST APIs
... DXLUX web interface
... MD-SAL clustering
. OpenDaylight projects and how to use them

//list all projects with updated documentation in this release. We are targeting OpenFlow, BCP-PCEP, AAA, Group-based policy, NIC, OpenStack Integration (Net-virt), OVSDB,VTN, Service Function Chaining.


== OpenDaylight overview and architecture

Here we take a closer look at ODL and its architecture. If you're already familiar with it and want to get on with installation, skip to Installing OpenDaylight.

//Installing ODL - clarify chapter title and state it above.



=== Running environment
ODL software is designed to run on a Java Virtual Machine (JVM). The platform is  based on the the Open Service Gateway Initiative (OSGi), which is a JVM service registry that provides a specification for ODL plugins, defining their lifecycle and how they interact with each other. Plugins use the JVM to publish, discover, and bind services in a service-oriented architecture (SOA). You can can use ODL on any operating system and hardware that has a Java Runtime Environment (JRE).

===Application and controller basics
Based on a microservices architecture, ODL applications consist of narrowly-focused, independently deployable services that communicate with each other using ODL's APIs, which allow you to control applications, protocols, and plugins. ODL's  centralized network controller oversees all network resources and alone directs all network traffic.  

===The OpenDaylight architecture
Figure 1 displays the ODL architecture.

//introduce and paste screenshot of ODL architecture from newer slide set. Jan Medved, slide 4. 

At the top of ODL sit network devices, Operating Support Systems (OSS) and Business Support Systems (BSS). OSS assembles services and helps operators build and optimize the network. Examples of OSS-enabled functions are:
.Watching a video
.Chatting online
.Using an application 

// Do I need to explain OSS and BSS? Sorta seems so for a user audience, but open to other opinions.

BSS enables operators to manage accounts and payments, customer support, service modification, and so on. Examples of BSS-enabled functions are: 
.Pre-paying an account
.Paying bills
.Buying and activating a new device
.Contacting customer service

Applications and services in Figure 1 include the following:
.NETCONF client, which provides mechanisms to install, manipulate, and delete the configuration of network devices using remote procedure calls (RPCs). The NETCONF protocol uses XML-based encoding to configure data and messages.
.APIs that provide a set of routines, protocols, and tools to build software applications for ODL. Developers use APIs to specify how software components should interact and free the developer from networking details and "getting under the hood."

//Colin - let's talk about this explanation. I want to clarify it. Thanks!

.Applications users want to run on ODL.
.REST on top of an application, which is used to build lightweight, mantainable, and scalable web services.
//Need help to clarify this.
.RESTCONF 


FigureIn the middle of the figure above, you see that the "Controller Core," which in ODL is a model-driven service abstraction layer (MD-SAL) architecture that unifies northboand and southbound APIs. Northbound APIs sit between the controller and application services, and they abstract and communicate network capabilities to define network flows for applications and implement application requests to the network relayed to it through northbound APIs. to ODL applications. NB APIs  abstracts the network capabilities/information and opens the abstract/logic network to applications. The northbound interface describes the area of protocol-supported communication between the controller and applications or higher layer control programs.In an enterprise data center, functions of northbound APIs include management solutions for automation and orchestration, and the sharing of actionable data between systems.

Southbound APIs enable communication between the ODL controller and network virtualization protocols.  

OSS/BSS??

Southbound protocol
In SDN, the southbound interface is the OpenFlow protocol specification. Its main function is to enable communication between the SDN controller and the network nodes (both physical and virtual switches and routers) so that the router can discover network topology, define network flows and implement requests relayed to it via northbound APIs. 



OpenFlow is a southbound protocol. With SDN, the controller tells the switch what to do.
OpenFlow is a controller that talks to the switch to set up a table to do the following:
1.	Drop the packet
2.	Send the packet in.
The controller can limit traffic through particular switches when it sees congestion.


//delete this: from Melissa: OpenDaylight uses a model-driven approach to describe the network, the functions to be performed on it and the resulting state or status achieved. By sharing YANG data structures in a common data store and messaging infrastructure, the core of OpenDaylight allows for fine-grained services to be created then combined together to solve more complex problems. In the ODL MD-SAL, any app or function can be bundled into a service that is then then loaded into the controller. Services can be configured and chained together in any number of ways to match fluctuating needs within the network. 
●	Only install the protocols and services you need 
●	Ability to combine multiple services and protocols to solve more complex problems as needs arise
●	Modular design allows anyone in the ODL ecosystem to leverage services created by others 








// TODO: uncomment the following lines when we have them to the point we think they're useful.
// OpenDaylight makes use of the following third-party tools:
//
// * *Maven*: OpenDaylight uses Maven for easier build automation. Maven uses pom.xml
// (Project Object Model) to script the dependencies between bundles.
//
// * *OSGi*: OSGi framework is the back-end of OpenDaylight as it allows dynamically
// loading bundles and packages JAR files, and binding bundles together for exchanging
// information.
//
// * *JAVA interfaces*: Java interfaces are usually generated by compiling the YANG project. Java interfaces are used for event listening, specifications, and forming
// patterns. This is the main way in which specific bundles implement call-back functions for events and also to indicate awareness of specific state.
//
// * *REST APIs*: Most of the REST APIs in OpenDaylight are defined using YANG tools and are RESTCONF APIs.
//
// * *Karaf*: TBD

For a more detailed information about OpenDaylight, see the and _OpenDaylight User Guide_, _OpenDaylight
Developer Guide_.

