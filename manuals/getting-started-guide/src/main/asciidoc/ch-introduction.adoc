 [preface]

== Introduction
The OpenDaylight (ODL) project is an open source, hardware-agnostic platform you can use to virtualize networking services based on your application's requirements, which is commonly referred to as Software-Defined Networking (SDN). In SDN the applications communicate their operating needs via APIs to a centralized controller, which oversees everything in the network. The controller alone directs all network communication based on component availability so your applications run at higher speeds with increased performance and scalability. 

When you deploy new applications in a traditional environment, engineers often have to modify the entire network to ensure ample and accurate resources to accommodate changes. For example, introducing virtual machines (VMs) increases datacenter network complexity and requires a high touch approach to ensure components still play together as required after any additions or changes. Switches can see only the switches directly next to them so don't have a comprehensive understanding of the network. With this limited information, the switches control all routing but far less efficiently because they can't see all the resources available to move traffic through the network. 

=== OpenDaylight goal
As a collaborative, open source project ODL's goal is to integrate open standards and open APIs to support a multitude of networking scenarios, accelerating adoption of SDN and Network Functions Virtualization (NFV). ODL's transparent approach works for your current networking needs and adapts to accommodate changes as application requirements and scope evolve. You can configure ODL's common platform in multiple ways to fit specific networking scenarios.

=== Who is this guide for and what's in it?
This document is for those considering or already using ODL, including IT decision-makers and end-users as well as developers and contributors to the project. ODL is supported by a global community and has a release cadence of roughly every six months, with the current Beryllium release preceded by Lithium, Helium, and the first release Hydrogen.

In this Getting Started Guide we explain the basics of ODL's architecture and components and provide installation instructions. ODL has more than 50 projects under its auspices that address specific networking requirements you may have and methods to execute against them. This document provides expanded explanations and use cases for several projects, including ones that are important for using OpenDaylight with OpenStack. As part of an ongoing effort, ODL is working to provide more use cases and case studies in the near future. For projects not covered here, we provide links to development documentation on the ODL wiki.

//list all projects with updated documentation in this release. We are targeting OpenFlow, BCP-PCEP, AAA, Group-based policy, NIC, OpenStack Integration (Net-virt), OVSDB,VTN, Service Function Chaining.

This document contains:
.OpenDaylight overview and architecture
.Installing OpenDaylight
- Target environment
- Known issues and limitations
- Download and install
* OpenDaylight Beryllium
* Components
* Support for REST APIs
* DXLUX web interface
* MD-SAL clustering
.OpenDaylight projects and how to use them

== OpenDaylight overview and architecture
Here we take a closer look at ODL and its architecture. If you're already familiar with it and want to get on with installation, skip to Installing OpenDaylight.

//Installing ODL - clarify chapter title and state it above.

=== Application and controller basics
Applications on the ODL platform are based on a microservices architecture consisting of narrowly-focused, independently deployable services that communicate with each other using APIs. ODL is efficienct and easily adaptable because application services are decoupled and the ODL controller alone directs all networking. Application developers abstract their networking needs with open APIs while the ODL platform ensures software programs can interoperate and communicate clearly and quickly.

//Jan-Simon suggested using an OpenStack use case above. I need someone with more technical knowledge to help with that. Colin? Follow up with Colin.

//create some other basic use cases. Ask Colin/Casey for something simple but widely needed/used.

//1. Case study – high-level of user doing something with ODL or SDN controller, e.g., provision routes across WAN.2. User Story/Study – what features need to be in ODL controller to allow participants to get something done. Gets into what is functionality and interface for ODL to exist.3. Case studies, e.g., how ATT is using OpenDaylight. More for User Guide but could use simple example here.

=== Running environment
ODL software is designed to run on a Java Virtual Machine (JVM). The platform is based on the the Open Service Gateway Initiative (OSGi) whose JVM service registry provides a specification for ODL plugins, defining their lifecycle and how they interact with each other. Plugins use the JVM to publish, discover, and bind services in a service-oriented architecture (SOA). You can can use ODL on any operating system and hardware that has a Java Runtime Environment (JRE).

=== OpenDaylight architecture
Figure 1 displays the ODL architecture.

//introduce and paste screenshot of ODL architecture from newer slide set. Jan Medved, slide 4. 

At the core of ODL is a model-drive service abstraction layer (MD-SAL). It unifies northbound  and southbound APIs and data structures for the controller's services and components. 

YANG [1] is a data modeling language for the NETCONF network configuration protocol. The name is an acronym for "Yet Another Next Generation". The YANG data modeling language was developed by the NETMOD [2] working group in the Internet Engineering Task Force (IETF) and was published as RFC 6020 in October 2010. The data modeling language can be used to model both configuration data as well as state data of network elements. Furthermore, YANG can be used to define the format of event notifications emitted by network elements and it allows data modelers to define the signature of remote procedure calls that can be invoked on network elements via the NETCONF protocol.

YANG is a modular language representing data structures in an XML tree format. The data modeling language comes with a number of builtin data types. Additional application specific data types can be derived from the builtin data types. More complex reusable data structures can be represented as groupings. YANG data models can use XPATH expressions to define constraints on the elements of a YANG data model.

It allows:

•	Modeling the structure of XML data and functionality provided by controller components.
•	Defining semantic elements and their relationships.
•	Modeling all the components as a single system
The XML nature of YANG data model allows self-describing data, which controller components and applications using the controller’s northbound APIs can consume in a raw format, along with the data’s schema.

Utilizing a schema language simplifies development of controller components and applications. A developer of a module that provides some functionality (a service, data, and functions/procedure) can define a schema and thus create simpler, statically typed APIs for the provided functionality, and thereby lower the risk of incorrect interpretation of data structures exposed through the Service Abstraction Layer.

DOM – a document object model – a tree structure. A DOM is the specification for how objects in a Web page (text, images, headers, links, etc.) are represented. The DOM defines what attributes are associated with each object, and how the objects and attributes can be manipulated. Dynamic HTML (DHTML) relies on the DOM to dynamically change the appearance of Web pages after they have been downloaded to a user's browser.
The DOM in ODL is YANG. It a programming interface for HTML, XML and SVG documents (SVG - Scalable Vector Graphics – is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation.) 
YANG provides a structured representation (a tree) of the document and it defines a way programs can access the structure so that they can change the document structure, style and content. YANG provides a representation of the document as a structured group of nodes and objects that have properties and methods. Nodes can also have event handlers attached to them, and once that event is triggered the event handlers get executed. Essentially, it connects web pages to scripts or programming languages.
Though often accessed using JavaScript, the DOM itself is not a part of the JavaScript language, and it can be accessed by other languages, though this is much less common.


ADL is We start from a user perspective at the top of ODL, with network devices, Operating Support Systems (OSS), and Business Support Systems (BSS). An example of an ODL user who would want these services could be a web provider that sells goods and services. The company's legacy network system may not be able to handle growth in customers, transactions, inventory, and customer service needs so it goes with ODL to accommodate expansion. OSS assembles services and helps operators build and optimize the network, with functions that enable:

.Watching a video
.Chatting online
.Using an application 

BSS enables operators to manage accounts and payments, customer support, service modification, and so on. Examples of BSS-enabled functions are: 
.Pre-paying an account
.Paying bills
.Buying and activating a new device
.Contacting customer service



Applications and services in Figure 1 include the following:
.NETCONF client, which provides mechanisms to install, manipulate, and delete the configuration of network devices using remote procedure calls (RPCs). The NETCONF protocol uses XML-based encoding to configure data and messages.
.APIs that provide a set of routines, protocols, and tools to build software applications for ODL. Developers use APIs to specify how software components should interact and free the developer from network administration.

//Colin - let's talk about this explanation. I want to clarify it. Thanks!

.Applications users want to run on ODL.
.REST on top of an application, which is used to build lightweight, mantainable, and scalable web services.
//Need help to clarify this.
.RESTCONF 


FigureIn the middle of the figure above, you see that the "Controller Core," which in ODL is a model-driven service abstraction layer (MD-SAL) architecture that unifies northboand and southbound APIs. Northbound APIs sit between the controller and application services, and they abstract and communicate network capabilities to define network flows for applications and implement application requests to the network relayed to it through northbound APIs. to ODL applications. NB APIs  abstracts the network capabilities/information and opens the abstract/logic network to applications. The northbound interface describes the area of protocol-supported communication between the controller and applications or higher layer control programs.In an enterprise data center, functions of northbound APIs include management solutions for automation and orchestration, and the sharing of actionable data between systems.

Southbound APIs enable communication between the ODL controller and network virtualization protocols.  

Southbound protocol
In SDN, the southbound interface is the OpenFlow protocol specification. Its main function is to enable communication between the SDN controller and the network nodes (both physical and virtual switches and routers) so that the router can discover network topology, define network flows and implement requests relayed to it via northbound APIs. 



OpenFlow is a southbound protocol. With SDN, the controller tells the switch what to do.
OpenFlow is a controller that talks to the switch to set up a table to do the following:
1.	Drop the packet
2.	Send the packet in.
The controller can limit traffic through particular switches when it sees congestion.


//delete this: from Melissa: OpenDaylight uses a model-driven approach to describe the network, the functions to be performed on it and the resulting state or status achieved. By sharing YANG data structures in a common data store and messaging infrastructure, the core of OpenDaylight allows for fine-grained services to be created then combined together to solve more complex problems. In the ODL MD-SAL, any app or function can be bundled into a service that is then then loaded into the controller. Services can be configured and chained together in any number of ways to match fluctuating needs within the network. 
●	Only install the protocols and services you need 
●	Ability to combine multiple services and protocols to solve more complex problems as needs arise
●	Modular design allows anyone in the ODL ecosystem to leverage services created by others 








// TODO: uncomment the following lines when we have them to the point we think they're useful.
// OpenDaylight makes use of the following third-party tools:
//
// * *Maven*: OpenDaylight uses Maven for easier build automation. Maven uses pom.xml
// (Project Object Model) to script the dependencies between bundles.
//
// * *OSGi*: OSGi framework is the back-end of OpenDaylight as it allows dynamically
// loading bundles and packages JAR files, and binding bundles together for exchanging
// information.
//
// * *JAVA interfaces*: Java interfaces are usually generated by compiling the YANG project. Java interfaces are used for event listening, specifications, and forming
// patterns. This is the main way in which specific bundles implement call-back functions for events and also to indicate awareness of specific state.
//
// * *REST APIs*: Most of the REST APIs in OpenDaylight are defined using YANG tools and are RESTCONF APIs.
//
// * *Karaf*: TBD

For a more detailed information about OpenDaylight, see the and _OpenDaylight User Guide_, _OpenDaylight
Developer Guide_.

